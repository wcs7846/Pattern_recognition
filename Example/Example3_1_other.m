clc;
clear;
close all;
%-------------------重要说明：这个程序还没有调好，虽然现在是可以运行的，但是并没有达到理想效果.........（然而现在并没有调试的思路）

%这个是练习3.1的实例程序---还是利用之前的例子来做感知器算法
%这次的感知器算法是基于之前的感知器算法来做了一定的改进---使之能够适应不可线性可分的分类目标（即袋式算法）
%------ 以下介绍以下袋式算法的改进部分：
%       1.定义一个存储向量ws（放在袋中）。为ws设置一个计数器hs（初始值为0）
%       2.在第t次迭代中，根据感知器规则计算更新值w(t+1)。用更新的权向量检测正确分类的训练向量个数。如果h>hs，用w(t+1)代替ws，用h代替
%       hs继续迭代
%------ 以下是一些重要的说明：
%       1.这个算法可以对不满足线性可分的分类任务可以进行正确的分类
%       2.这个算法的迭代次数是预先设定的而不像之前是无限迭代知道找到最佳值为止
%------ 以下是一些个人对算法的改进说明：
%       1.由于上面关于袋式算法的描述里面对h参量的描述很模糊，导致编程时很难实现。所以进行调整，即分别计算加权向量和不加权向量时分类
%         错误的个数。如果不加时错误更少则重新计算权向量---也可以采用其他的办法，但是不能直接不处理，不然会无限循环
%       2.采用上述的方法会使得每次循环的时间更加的长--必要的代价（毕竟要适应更大的）
%       3.算法的基本思想是利用最小误分类的思想来做的
randn('seed',0);
P1=[1  1];
m1=[1 8]';
m2=[8 1]';
sita=sqrt(4);
S1=(sita^2)*eye(2);
S2=S1;
N=1000;
x1_Source=mvnrnd(m1,S1,N);
x2_Source=mvnrnd(m2,S2,N);
x1=P1(1)*x1_Source;
x2=P1(2)*x2_Source;
figure(1);
%这里是显示的训练数据
plot(x1_Source((1:N/2),1),x1_Source((1:N/2),2),'ro','MarkerSize',3);hold on;
plot(x2_Source((1:N/2),1),x2_Source((1:N/2),2),'bo','MarkerSize',3);hold on;
X1xlf=[x1(1:(N/2),:);x2(1:(N/2),:)];
%这里是显示的未训练数据
plot(x1_Source(((N/2)+1:N),1),x1_Source(((N/2)+1:N),2),'mo','MarkerSize',3);hold on;
plot(x2_Source(((N/2)+1:N),1),x2_Source(((N/2)+1:N),2),'mo','MarkerSize',3);hold on;
X1xln=[x1((N/2)+1:N,:);x2((N/2)+1:N,:)];
%在第二个图中显示
figure(2);
plot(x1_Source((1:N/2),1),x1_Source((1:N/2),2),'ro','MarkerSize',3);hold on;
plot(x2_Source((1:N/2),1),x2_Source((1:N/2),2),'bo','MarkerSize',3);hold on;
%---------------------------------------------------------------------------------------------------------
x0=1/N*sum(X1xlf);
plot(x0(1),x0(2),'g+','MarkerSize',7);hold on;
%假定权向量为[1 1 b]--b为根据x0求出来的值
b=0;%这个是初始值
w0=[1 1 b];
b=-w0(1)*x0(1)-w0(2)*x0(2);
w0=[1 1 b];
%---------------------------------------------------------------------------------------------------------
%画出权向量
n1=X1xlf(:,1)';
n2=-5:(25/(length(n1)-1)):20;
for n=1:1:length(n1)
    n2(n)=(-w0(1)*n1(n)-w0(3))/w0(2);
end
plot(n1,n2,'g.','MarkerSize',3);hold on;
%---------------------------------------------------------------------------------------------------------
%感知器算法
%权向量的形式为：ax1+bx2+c=0<---->w=[a,b,c]'
%计算系数siertax
ww1=[x1,ones(size(x1,1),1)]; 
ww2=[x2,ones(size(x2,1),1)]; 
X=[ww1;-ww2];
W=w0';
ok=0;
%定义标志
hs=0;
ws=w0';%此处随意初始化一个就好
%初始化基本参数
Ro=0.05;
Rot=Ro;
k_before=0;%用来计数
k_after=0;
%循环体
while(ok==0)
    hs=0;
    k_before=0;%此处为清零
    for n=1:size(X,1)
        if (W'*X(n,:)'<0) %注：只有错误分类的时候才会<0
            k_before=k_before+1;
            if hs==0    %检测是否是第一次分类错误
                hs=1;
                ws=X(n,:)';     %记录一下向量
            end
        end
    end
    W=W+ws;
    k_after=0;
    for n=1:size(X,1)
        if (W'*X(n,:)'<0)
            k_after=k_after+1;
        end
    end
    if k_before<k_after
       W=W-2*ws; 
    elseif k_before==k_after
        ok=1;
    end
end
%重新画一下直线
%n1=X1xlf(:,1)';
n2=-W(1)*n1/W(2)-W(3)/W(2); 
plot(n1,n2,'m.','MarkerSize',3);hold on;
%---------------------------------------------------------------------------------------------------------
%利用权向量进行分类
nfx1=X1xln(:,1)';
nfx2=X1xln(:,2)';
for n=1:1:length(nfx1)
    if m1(2)>m2(2)
        if nfx2(n)>n2(n)
            plot(nfx1(n),nfx2(n),'r+','MarkerSize',3);hold on;
        else
            plot(nfx1(n),nfx2(n),'b+','MarkerSize',3);hold on;
        end
    else
        if nfx2(n)<n2(n)
            plot(nfx1(n),nfx2(n),'r+','MarkerSize',3);hold on;
        else
            plot(nfx1(n),nfx2(n),'b+','MarkerSize',3);hold on;
        end
    end
end
%---------------------------------------------------------------------------------------------------------